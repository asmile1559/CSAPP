## 计算机中如何表示浮点数

### 定点数:

![](images/Float%20Point-浮点数的表示.png)

这种表示存在问题, 比如很多数值 (不是 2 的幂次), 那么就不能精确表示, 因为小数点的位置已经确定了, 这种情况下精度也是确定的

### 浮点数:

浮点数在一定程度上解决了定点数的问题, 因为它可以在表示小数的时候更多位表示小数, 表示整数的时候, 更多位表示整数, 虽然仍然受到限制, 但是却更加精确了

浮点数有如下的表示形式

![](images/Float%20Point-i3e的浮点数规范.png)

根据浮点数的形式, 可以计算出浮点数的数值: 其中s是上图中的s, E和M下文会有解释, M表示一个 $(1.0, 2.0]$ 的浮点数

$$ \text{float} = (-1)^{s} \cdot M \cdot 2^{E}$$ 
![](images/Float%20Point-三种浮点数.png)

### 对 E, M的解释

1. 对于一个标准的浮点数而言, exp 不允许全0或者全1
 
exp被编码为偏置值: $E = Exp - Bias$ 
其中 Exp 是exp表示的无符号数,  $Bias = 2^{k-1}-1$  当 k 是exp 的部分的长度, 对于单精度数就是 $2^{(8-1)}-1=127$ 对于双精度就是 $2^{(11-1)}-1=1023$  

因此对于单精度数而言 $E$ 的范围是 $[-126, 127]$  $(exp \in [1, 254])$ \
对于多精度数  $E$ 的范围是 $[-1022, 1023]$  $(exp \in [1, 254])$ 

**为什么要使用偏置方法定义浮点数的exp位呢?** 因为可以按照无符号数的方式进行大小和相等的比较, 而不需要考虑符号(补码)的问题!

2. 对于尾数 $M$ ,它被隐编码为 1.xxxx, 其中 xxxx是frac部分的数, 因此说 M是一个介于1.0 和 2.0 且接近于2.0的数
3. 由于标准浮点数的性质, 它永远不可能取到0到标准浮点数表示的最小值之间的数, 因此引入了非标准浮点数, 进行补充, 在非标准浮点数与标准浮点数是同时存在的, 在表示不同范围时使用
==注意E是公式的指数, exp是位数, 不要搞反, E = exp-bias== 

### 非标准的浮点数

**在非标准浮点数的计算中, M没有隐含的数字1** , exp此时全为 0 , 这种情况下 $E = 1 - Bias = -126$ 是一个恒定值, 浮点数的符号取决于exp最前面的一位是否为0,(**s**)

借助非标准浮点数(粉色区域) 补充了在零附近的定义
![](images/Float%20Point-标准浮点数与非标准浮点数.png)

### 特殊值

**在特殊值中, Exp全为1**, 特殊值是另一种标准浮点数的补充, 它是对无穷大的方向的补充
* 如果尾数 `frac` 全为零, 那么表示为无穷, 同时包括正负无穷
* 如果尾数 `frac` 不全为零, 那么表示 NaN 

 ![](images/Float%20Point-非标准数的作用.png)

非标准数使得过度变的平滑, 没有突变点

## 浮点数的运算

对运算结果进行舍入, 一般有四种常见的舍入方法:

![](images/Float%20Point-四种舍入.png)

i3e使用第四种舍入方法, 也即四舍六入五向偶

![](images/Float%20Point-二进制的例子.png)

### 浮点数乘法

![](images/Float%20Point-浮点数乘法.png)

### 浮点数加法

![](images/Float%20Point-浮点数加法.png)

浮点数加法要先**对齐**, 再运算!  对齐到 E1

## 浮点数的数学性质

浮点数加法不具备结合律, 但具备交换律

![](images/Float%20Point-浮点数加法的一些数学性质.png)

![](images/Float%20Point-浮点数乘法的数学性质.png)

## C语言中的浮点数

![](images/Float%20Point-C语言中的浮点数.png)

整数是否可以无失真的转换为浮点数? **需要比较整数的位数和浮点数的 frac 位数**, 当 frac 位数多于整数位数, 则可以无失真的转换, 否则则会损失一些精度


